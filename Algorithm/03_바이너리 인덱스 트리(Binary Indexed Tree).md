# 바이너리 인덱스 트리(Binary Indexed Tree)

## 데이터 업데이트가 가능한 상황에서의 구간 합

### BOJ '구간 합 구하기' 문제(2042)

### 문제

어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.

### 입력

첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.

입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.

### 출력

첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.

### 해결

- 바이너리 인덱스 트리는 2진법 인덱스 구조를 활용해 구간 합 문제를 효과 적으로 해결해 줄 수 있는 자료구조
- 정수에 따른 2진수 표기
  - 정수 7 -> 2진수 00000000 00000000 00000000 0000111
  - 정수 -7 -> 2진수 11111111 11111111 11111111 1111001

#### 비트연산자

	1. **NOT( ~ )**

    - 비트 열을 반전 - 비트가 1이면 0으로, 0이면 1로 반전

	2. **OR( | )**

    - A OR B가 1이면 1출력

	3. **AND( & )**

    - AND연산자는 두 비트열 모두 1일때 1이 출력

	4. **XOR( ^ )**

    - 두 비트열 중 1이 **하나만** 있을 때 답이 1이 된다. 또는 1이 홀수개 일때 1이 된다.

    - ```python
      0 ^ 0 = 0
      0 ^ 1 = 1
      1 ^ 0 = 1
      1 ^ 1 = 0
      ```

	5. **SHIFT( <<, >> )**

    - 비트를 옮기는 연산을 수행

    - ```python
      0011 0110 << 3 = 1011 0000	# << 연산은 가장 오른쪽 부분에 0으로 채워진다. 왼쪽 부분에 1이 넘어가면 그냥 없어진다.
      
      0011 1100 >> 3 = 0000 0111 # >> 연산은 가장 상위 비트 MSB(Most Significant Bit)가 0이면 왼쪽부터 0으로 채워지고, MSB가 1이면 왼쪽부터 1로 채워진다!
      ```

    - 컴퓨터에서 MSB가 0이면 양수, 1이면 음수를 나타낸다.

	6. **2의 보수법**

    - 1111 1001은 MSB가 1이므로 음수입니다. 이때 2의 보수를 사용합니다.

      1. MSB를 제외하고 비트를 반전시킨다(이것이 1의 보수법)

      2. 1을 더해준다(1을 더해주는 것이 2의 보수법)

      3. 1, 2 번 두가지 방법을 통해 1111 1001의 음수값을 구하면

         ```python
         1000 0110 (1111 1001의 반전)
         0000 0001 (1을 더해주는 2의 보수)
         -------------------
         1000 0111 # -7
         ```

    - 2의 보수값을 수하려면

      - `k & -k` AND 비트연산을 수행

#### 트리 구조 만들기

- 0이 아닌 마지막 비트 = 내가 저장하고 있는 값들의 개수
  - 홀수는 마지막 비트가 1이어서 1개만 저장
- 특정 값을 변경할 때(update)
  - 0이 아닌 마지막 비트만큼 더하면서 구간들의 값을 변경
    1. 3을 변경한다고 했을때 
    2. 범위에 속해있는 1 ~ 4, 1 ~ 8, 1 ~ 16의 범위를 변경
- 1부터 N까지의 합(누적 합_Prefix Sum) 구하기
  - 0이 아닌 마지막 비트만큼 빼면서 구간들의 값의 합 계산
    1. 11부터 한다고하면 11은 0이 아닌 마지막 값이 1이니까 11하나만 계산
    2. 10에서 범위해 해당하는 9 ~ 10의 합 계산
    3. 나머지 1 ~ 8 범위에 해당하는 값의 합 계산

### code

```python
import sys
input = sys.stdin.readline

# 데이터의 개수(n), 변경 횟수(m), 구간 합 계산 횟수(k)
n, m, k = map(int, input().split())

# 전체 데이터의 개수는 최대 1,000,000개
arr = [0] * (n + 1)
tree = [0] * (n + 1)

# i번째 수까지의 누적 합을 계산하는 함수
def prefix_sum(i):
    result = 0
    while i > 0:
        result += tree[i]
        # 0이 아닌 마지막 비트만큼 빼가면서 이동
        i -= (i & -i)
    return result

# i번째 수를 dif만큼 더하는 함수
def update(i, dif):
    while i <= n:
        tree[i] += dif
        i += (i & -i)
        
# start부터 end까지의 구간 합을 계산하는 함수
def interval_sum(start, end):
    # 범위 끝의 누적합에서 시작 범위 바로 이전까지의 누적합을 빼준다.
    return prefix_sum(end) - prefix_sum(start - 1)

for i in range(1, n + 1):
    x = int(input())
    arr[i] = x
    update(i, x)
    
for i in range(m + k):
    a, b, c = map(int, input().split())
    # 업데이트(update) 연산인 경우
    if a == 1:
        update(b, c - arr[b]) # 바뀐 크기(dif)만큼 적용
        arr[b] = c
    # 구간 합(interval sum) 연산인 경우
    else:
        print(interval_sum(b, c))
```

